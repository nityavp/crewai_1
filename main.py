# -*- coding: utf-8 -*-
"""crewaimultiple input.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iuWcb8K0HnWTGtqMTVZ4xjICLO-zZ0f1
"""
import streamlit as st
import sqlite3

from crewai import Crew, Agent, Task, Process

import os
os.environ["OPENAI_API_KEY"] = ""
model=os.environ.get("OPENAI_MODEL_NAME", "gpt 3.5 turbo")

Address_matcher= Agent(
    role='senior Address Validator',
    goal='You task is to take input address and match it with given address and categorised it into matched, no match and area level match',
    verbose=True,
    memory=True,
    backstory=(
    "Driven by analytical skills, you're at the forefront of"
    "matching data even if it is jumbled combination"
    "the world."
    ),
   allow_delegation=True
)

name_matcher= Agent(
    role='senior Address Validator',
    goal=' You task is to see if address_matcher given matched or matched area level, if yes then match input name with given name and give output value as (matched or not matched), if address not matched by address_matcher you can skip matching name',
    verbose=True,
    memory=True,
    backstory=(
    "Driven by analytical skills, you're at the forefront of"
    "matching data even if it is jumbled combination"
    "the world."
    ),
   allow_delegation=True
)

Validator = Agent(
    role='Validator',
    goal='Cross verify wether the answer by address_matcher and name_matcher is correct or not and give final answer as(matched or not matched)',
    verbose=True,
    backstory=(
    "Driven by validation of analytical answers, you're at the forefront of"
    "matching data even if it is jumbled combination"
    "the world."
    ),
   allow_delegation=True

)

address_matching_task = Task(
    description='You task is to take {inputaddress} with the {givenaddress} and marked it in bucket(matched, not matched, matched area level)',
    expected_output='matched, not matched, matched area level',
    async_execution=True,
    agent=Address_matcher
    )

name_matching_task = Task(
    description='Your task is to see if address_matcher given matched or matched area level, if yes then match {inputname} with {givenname} and give output value as (matched or not matched), if address not matched by address_matcher you can skip matching name',
    expected_output='matched, not matched, matched area level',
    async_execution=True,
    agent=name_matcher,
    context=[address_matching_task ]
    )

Validation = Task(
    description="you have to check weather the address_matcher and name_matcher agent give write answer in matching address and name or not, if yes give the final answer if no correct it and give final answer as matched or not matched",
    expected_output='matched or not matched (one word answer)',
    agent=Validator,
    context=[address_matching_task ,name_matching_task]
)

my_crew = Crew(
    agents=[Address_matcher, name_matcher,Validator],
    tasks=[address_matching_task ,name_matching_task,Validation],
    process=Process.sequential,
    full_output=True,
    verbose=True,
)


# Creating text input for names


# Define a function to check login credentials
def authenticate(username, password):
    # Replace this with your authentication logic
    return username == "valuepitch" and password == "vp@2024"

# Create a login form in the sidebar
with st.sidebar.form("login_form"):
    username = st.text_input("Username")
    password = st.text_input("Password", type="password")
    submitted = st.form_submit_button("Login")

# Check if login form is submitted
if submitted:
    if authenticate(username, password):
        st.sidebar.success("Login Successful!")
        st.session_state['authenticated'] = True
    else:
        st.sidebar.error("Invalid username or password")

# Check if user is authenticated before displaying the main form
if st.session_state.get('authenticated'):
    with st.form("my_form"):
        input_address = st.text_input("Input Address", value=st.session_state.get('input_address', ''))
        given_address = st.text_input("Given Address", value=st.session_state.get('given_address', ''))
        input_name = st.text_input("Input Name", value=st.session_state.get('input_name', ''))
        given_name = st.text_input("Given Name", value=st.session_state.get('given_name', ''))
        
        # Every form must have a submit button.
        submitted = st.form_submit_button("Kickoff Matching")

    if submitted:
        try:
            # Store inputs in session state
            st.session_state['input_address'] = input_address
            st.session_state['given_address'] = given_address
            st.session_state['input_name'] = input_name
            st.session_state['given_name'] = given_name

            # Correcting the dictionary syntax
            result = my_crew.kickoff(inputs={
                'inputaddress': input_address,
                'givenaddress': given_address,
                'inputname': input_name,
                'givenname': given_name
            })

            # Store result in session state
            st.session_state['result'] = result

        except Exception as e:
            st.session_state['result'] = f"An error occurred: {e}"

    # Display the result if available
    if 'result' in st.session_state:
        st.write(st.session_state['result'])
else:
    st.warning("Please log in to access the application.")
